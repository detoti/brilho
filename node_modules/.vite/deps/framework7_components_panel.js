import {
  getSupport
} from "./chunk-CMOS4D7O.js";
import {
  class_default
} from "./chunk-GBDLSSFZ.js";
import {
  dom7_default
} from "./chunk-GWMKRGKK.js";
import {
  deleteProps,
  extend,
  nextFrame,
  now
} from "./chunk-UUGCU45C.js";
import {
  getDocument
} from "./chunk-PRZ7VHHA.js";
import "./chunk-ZS7NZCD4.js";

// node_modules/framework7/components/panel/swipe-panel.js
function swipePanel(panel) {
  const app = panel.app;
  if (panel.swipeInitialized) {
    return;
  }
  extend(panel, {
    swipeable: true,
    swipeInitialized: true
  });
  const params = panel.params;
  const {
    $el,
    $backdropEl,
    side,
    effect
  } = panel;
  let otherPanel;
  let isTouched;
  let isGestureStarted;
  let isMoved;
  let isScrolling;
  let isInterrupted;
  const touchesStart = {};
  let touchStartTime;
  let touchesDiff;
  let translate;
  let backdropOpacity;
  let panelWidth;
  let direction;
  let $viewEl;
  let touchMoves = 0;
  function handleTouchStart(e) {
    if (!panel.swipeable || isGestureStarted)
      return;
    if (!app.panel.allowOpen || !params.swipe && !params.swipeOnlyClose || isTouched)
      return;
    if (dom7_default(".modal-in:not(.toast):not(.notification), .photo-browser-in").length > 0)
      return;
    otherPanel = app.panel.get(side === "left" ? "right" : "left") || {};
    const otherPanelOpened = otherPanel.opened && otherPanel.$el && !otherPanel.$el.hasClass("panel-in-breakpoint");
    if (!panel.opened && otherPanelOpened) {
      return;
    }
    if (!params.swipeOnlyClose) {
      if (otherPanelOpened)
        return;
    }
    if (e.target && e.target.nodeName.toLowerCase() === "input" && e.target.type === "range")
      return;
    if (dom7_default(e.target).closest(".range-slider, swiper-container.tabs, .calendar-months, .no-swipe-panel, .card-opened").length > 0)
      return;
    touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    if (params.swipeOnlyClose && !panel.opened) {
      return;
    }
    if (params.swipeActiveArea && !panel.opened) {
      if (side === "left") {
        if (touchesStart.x > params.swipeActiveArea)
          return;
      }
      if (side === "right") {
        if (touchesStart.x < app.width - params.swipeActiveArea)
          return;
      }
    }
    touchMoves = 0;
    $viewEl = dom7_default(panel.getViewEl());
    isMoved = false;
    isTouched = true;
    isScrolling = void 0;
    isInterrupted = false;
    touchStartTime = now();
    direction = void 0;
  }
  function handleTouchMove(e) {
    if (!isTouched || isGestureStarted || isInterrupted)
      return;
    touchMoves += 1;
    if (touchMoves < 2)
      return;
    if (e.f7PreventSwipePanel || app.preventSwipePanelBySwipeBack || app.preventSwipePanel) {
      isTouched = false;
      return;
    }
    const pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
    const pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
    if (typeof isScrolling === "undefined") {
      isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
    }
    if (isScrolling) {
      isTouched = false;
      return;
    }
    if (!direction) {
      if (pageX > touchesStart.x) {
        direction = "to-right";
      } else {
        direction = "to-left";
      }
      if (params.swipeActiveArea > 0 && !panel.opened) {
        if (side === "left" && touchesStart.x > params.swipeActiveArea) {
          isTouched = false;
          return;
        }
        if (side === "right" && touchesStart.x < app.width - params.swipeActiveArea) {
          isTouched = false;
          return;
        }
      }
      if ($el.hasClass("panel-in-breakpoint")) {
        isTouched = false;
        return;
      }
      if (side === "left" && direction === "to-left" && !$el.hasClass("panel-in") || side === "right" && direction === "to-right" && !$el.hasClass("panel-in")) {
        isTouched = false;
        return;
      }
    }
    let threshold = panel.opened ? 0 : -params.swipeThreshold;
    if (side === "right")
      threshold = -threshold;
    if (!isMoved) {
      if (!panel.opened) {
        panel.insertToRoot();
        $el.addClass("panel-in-swipe");
        if ($backdropEl)
          $backdropEl.css("visibility", "visible");
        $el.trigger("panel:swipeopen");
        panel.emit("local::swipeOpen panelSwipeOpen", panel);
      }
      panelWidth = $el[0].offsetWidth;
      if (effect === "reveal" && $el.hasClass("panel-in-collapsed")) {
        panelWidth -= parseFloat($viewEl.css(`margin-${side}`));
      }
      $el.transition(0);
    }
    isMoved = true;
    if (e.cancelable) {
      e.preventDefault();
    }
    touchesDiff = pageX - touchesStart.x + threshold;
    const startTranslate = effect === "floating" ? 8 : 0;
    if (side === "right") {
      if (effect === "cover" || effect === "push" || effect === "floating") {
        translate = touchesDiff + (panel.opened ? startTranslate : panelWidth);
        if (translate < 0 - startTranslate)
          translate = -startTranslate;
        if (translate > panelWidth) {
          translate = panelWidth;
        }
      } else {
        translate = touchesDiff - (panel.opened ? panelWidth : 0);
        if (translate > 0)
          translate = 0;
        if (translate < -panelWidth) {
          translate = -panelWidth;
        }
      }
    } else {
      translate = touchesDiff + (panel.opened ? panelWidth : startTranslate);
      if (translate < 0)
        translate = 0;
      if (translate > panelWidth + startTranslate) {
        translate = panelWidth + startTranslate;
      }
    }
    const noFollowProgress = Math.abs(translate / panelWidth);
    if (effect === "reveal") {
      if (!params.swipeNoFollow) {
        $viewEl.transform(`translate3d(${translate}px,0,0)`).transition(0);
        if ($backdropEl)
          $backdropEl.transform(`translate3d(${translate}px,0,0)`).transition(0);
      }
      $el.trigger("panel:swipe", Math.abs(translate / panelWidth));
      panel.emit("local::swipe panelSwipe", panel, Math.abs(translate / panelWidth));
    } else {
      if (side === "left")
        translate -= panelWidth;
      if (!params.swipeNoFollow) {
        backdropOpacity = 1 - Math.abs(translate / panelWidth);
        if ($backdropEl) {
          $backdropEl.transition(0);
          $backdropEl.css({
            opacity: backdropOpacity
          });
        }
        $el.transform(`translate3d(${translate}px,0,0)`).transition(0);
        if (effect === "push") {
          const viewTranslate = side === "left" ? translate + panelWidth : translate - panelWidth;
          $viewEl.transform(`translate3d(${viewTranslate}px,0,0)`).transition(0);
          if ($backdropEl) {
            $backdropEl.transform(`translate3d(${viewTranslate}px,0,0)`).transition(0);
          }
        }
      }
      $el.trigger("panel:swipe", Math.abs(translate / panelWidth));
      panel.emit("local::swipe panelSwipe", panel, Math.abs(translate / panelWidth));
    }
    if (params.swipeNoFollow) {
      const stateChanged = panel.opened && noFollowProgress === 0 || !panel.opened && noFollowProgress === 1;
      if (stateChanged) {
        isInterrupted = true;
        handleTouchEnd(e);
      }
    }
  }
  function handleTouchEnd(e) {
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    const isGesture = e.type === "gesturestart" || isGestureStarted;
    isTouched = false;
    isMoved = false;
    const timeDiff = (/* @__PURE__ */ new Date()).getTime() - touchStartTime;
    let action;
    const startTranslate = effect === "floating" ? side === "left" ? 8 : -8 : 0;
    const edge = (translate === startTranslate || Math.abs(translate) === panelWidth) && !params.swipeNoFollow;
    const threshold = params.swipeThreshold || 0;
    if (isGesture) {
      action = "reset";
    } else if (!panel.opened) {
      if (Math.abs(touchesDiff) < threshold) {
        action = "reset";
      } else if (effect === "cover" || effect === "push" || effect === "floating") {
        if (translate === 0 + startTranslate) {
          action = "swap";
        } else if (timeDiff < 300 && Math.abs(translate) > 0) {
          action = "swap";
        } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
          action = "swap";
        } else {
          action = "reset";
        }
      } else if (translate === 0) {
        action = "reset";
      } else if (timeDiff < 300 && Math.abs(translate) > 0 || timeDiff >= 300 && Math.abs(translate) >= panelWidth / 2) {
        action = "swap";
      } else {
        action = "reset";
      }
    } else if (effect === "cover" || effect === "push" || effect === "floating") {
      if (translate === 0) {
        action = "reset";
      } else if (timeDiff < 300 && Math.abs(translate) > 0) {
        action = "swap";
      } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
        action = "reset";
      } else {
        action = "swap";
      }
    } else if (translate === -panelWidth) {
      action = "reset";
    } else if (timeDiff < 300 && Math.abs(translate) >= 0 || timeDiff >= 300 && Math.abs(translate) <= panelWidth / 2) {
      if (side === "left" && translate === panelWidth)
        action = "reset";
      else
        action = "swap";
    } else {
      action = "reset";
    }
    if (action === "swap") {
      if (panel.opened) {
        panel.close(!edge);
      } else {
        panel.open(!edge);
      }
    }
    let removePanelInClass = true;
    if (action === "reset") {
      if (!panel.opened) {
        if (edge) {
          $el.removeClass("panel-in-swipe");
        } else {
          removePanelInClass = false;
          const target = effect === "reveal" ? $viewEl : $el;
          panel.setStateClasses("before-closing");
          target.transitionEnd(() => {
            if ($el.hasClass("panel-in"))
              return;
            $el.removeClass("panel-in-swipe");
            panel.setStateClasses("after-closing");
          });
        }
      }
    }
    if (effect === "reveal" || effect === "push") {
      nextFrame(() => {
        $viewEl.transition("");
        $viewEl.transform("");
      });
    }
    if (removePanelInClass) {
      $el.removeClass("panel-in-swipe");
    }
    $el.transition("").transform("");
    if ($backdropEl) {
      $backdropEl.transform("").transition("").css({
        opacity: "",
        visibility: ""
      });
    }
  }
  function handleGestureStart(e) {
    isGestureStarted = true;
    handleTouchEnd(e);
  }
  function handleGestureEnd() {
    isGestureStarted = false;
  }
  app.on("touchstart:passive", handleTouchStart);
  app.on("touchmove:active", handleTouchMove);
  app.on("touchend:passive", handleTouchEnd);
  app.on("gesturestart", handleGestureStart);
  app.on("gestureend", handleGestureEnd);
  panel.on("panelDestroy", () => {
    app.off("touchstart:passive", handleTouchStart);
    app.off("touchmove:active", handleTouchMove);
    app.off("touchend:passive", handleTouchEnd);
    app.off("gesturestart", handleGestureStart);
    app.off("gestureend", handleGestureEnd);
  });
}
var swipe_panel_default = swipePanel;

// node_modules/framework7/components/panel/resizable-panel.js
function resizablePanel(panel) {
  const app = panel.app;
  const support = getSupport();
  if (panel.resizableInitialized)
    return;
  extend(panel, {
    resizable: true,
    resizableWidth: null,
    resizableInitialized: true
  });
  const $htmlEl = dom7_default("html");
  const {
    $el,
    $backdropEl,
    side,
    effect
  } = panel;
  if (!$el)
    return;
  let isTouched;
  let isMoved;
  const touchesStart = {};
  let touchesDiff;
  let panelWidth;
  let $viewEl;
  let panelMinWidth;
  let panelMaxWidth;
  let visibleByBreakpoint;
  const isPushingPanel = effect !== "cover" && effect !== "floating";
  function transformCSSWidth(v) {
    if (!v)
      return null;
    if (v.indexOf("%") >= 0 || v.indexOf("vw") >= 0) {
      return parseInt(v, 10) / 100 * app.width;
    }
    const newV = parseInt(v, 10);
    if (Number.isNaN(newV))
      return null;
    return newV;
  }
  function isResizable() {
    return panel.resizable && $el.hasClass("panel-resizable");
  }
  function handleTouchStart(e) {
    if (!isResizable())
      return;
    touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    isMoved = false;
    isTouched = true;
    panelMinWidth = transformCSSWidth($el.css("min-width"));
    panelMaxWidth = transformCSSWidth($el.css("max-width"));
    visibleByBreakpoint = $el.hasClass("panel-in-breakpoint");
  }
  function handleTouchMove(e) {
    if (!isTouched)
      return;
    const pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
    if (!isMoved) {
      panelWidth = $el[0].offsetWidth;
      $el.transition(0);
      $el.addClass("panel-resizing");
      $htmlEl.css("cursor", "col-resize");
      if (isPushingPanel || visibleByBreakpoint) {
        $viewEl = dom7_default(panel.getViewEl());
        if (panel.$containerEl && panel.$containerEl.hasClass("page")) {
          $viewEl.add(panel.$containerEl.children(".page-content, .tabs, .fab"));
        }
      }
      if (isPushingPanel && !visibleByBreakpoint) {
        $backdropEl.transition(0);
        $viewEl.transition(0);
      }
    }
    isMoved = true;
    e.preventDefault();
    touchesDiff = pageX - touchesStart.x;
    let newPanelWidth = side === "left" ? panelWidth + touchesDiff : panelWidth - touchesDiff;
    if (panelMinWidth && !Number.isNaN(panelMinWidth)) {
      newPanelWidth = Math.max(newPanelWidth, panelMinWidth);
    }
    if (panelMaxWidth && !Number.isNaN(panelMaxWidth)) {
      newPanelWidth = Math.min(newPanelWidth, panelMaxWidth);
    }
    newPanelWidth = Math.min(Math.max(newPanelWidth, 0), app.width);
    panel.resizableWidth = newPanelWidth;
    $el[0].style.width = `${newPanelWidth}px`;
    if (isPushingPanel && !visibleByBreakpoint) {
      if ($viewEl) {
        $viewEl.transform(`translate3d(${side === "left" ? newPanelWidth : -newPanelWidth}px, 0, 0)`);
      }
      if ($backdropEl) {
        $backdropEl.transform(`translate3d(${side === "left" ? newPanelWidth : -newPanelWidth}px, 0, 0)`);
      }
    } else if (visibleByBreakpoint && $viewEl) {
      $viewEl.css(`margin-${side}`, `${newPanelWidth}px`);
    }
    $el.trigger("panel:resize", newPanelWidth);
    panel.emit("local::resize panelResize", panel, newPanelWidth);
  }
  function handleTouchEnd() {
    dom7_default("html").css("cursor", "");
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    isTouched = false;
    isMoved = false;
    $htmlEl[0].style.setProperty(`--f7-panel-${side}-width`, `${panel.resizableWidth}px`);
    $el[0].style.width = "";
    if (isPushingPanel && !visibleByBreakpoint) {
      $viewEl.transform("");
      $backdropEl.transform("");
    }
    $el.removeClass("panel-resizing");
    nextFrame(() => {
      $el.transition("");
      if (isPushingPanel) {
        $backdropEl.transition("");
        if ($viewEl)
          $viewEl.transition("");
      }
    });
  }
  function handleResize() {
    if (!panel.opened || !panel.resizableWidth)
      return;
    panelMinWidth = transformCSSWidth($el.css("min-width"));
    panelMaxWidth = transformCSSWidth($el.css("max-width"));
    if (panelMinWidth && !Number.isNaN(panelMinWidth) && panel.resizableWidth < panelMinWidth) {
      panel.resizableWidth = Math.max(panel.resizableWidth, panelMinWidth);
    }
    if (panelMaxWidth && !Number.isNaN(panelMaxWidth) && panel.resizableWidth > panelMaxWidth) {
      panel.resizableWidth = Math.min(panel.resizableWidth, panelMaxWidth);
    }
    panel.resizableWidth = Math.min(Math.max(panel.resizableWidth, 0), app.width);
    $htmlEl[0].style.setProperty(`--f7-panel-${side}-width`, `${panel.resizableWidth}px`);
  }
  if (panel.$el.find(".panel-resize-handler").length === 0) {
    panel.$el.append('<div class="panel-resize-handler"></div>');
  }
  panel.$resizeHandlerEl = panel.$el.children(".panel-resize-handler");
  $el.addClass("panel-resizable");
  const passive = support.passiveListener ? {
    passive: true
  } : false;
  panel.$el.on(app.touchEvents.start, ".panel-resize-handler", handleTouchStart, passive);
  app.on("touchmove:active", handleTouchMove);
  app.on("touchend:passive", handleTouchEnd);
  app.on("resize", handleResize);
  panel.on("beforeOpen", handleResize);
  panel.once("panelDestroy", () => {
    $el.removeClass("panel-resizable");
    panel.$resizeHandlerEl.remove();
    panel.$el.off(app.touchEvents.start, ".panel-resize-handler", handleTouchStart, passive);
    app.off("touchmove:active", handleTouchMove);
    app.off("touchend:passive", handleTouchEnd);
    app.off("resize", handleResize);
    panel.off("beforeOpen", handleResize);
  });
}
var resizable_panel_default = resizablePanel;

// node_modules/framework7/components/panel/panel-class.js
var Panel = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    const extendedParams = extend({
      on: {}
    }, app.params.panel, params);
    super(extendedParams, [app]);
    const panel = this;
    panel.params = extendedParams;
    panel.$containerEl = panel.params.containerEl ? dom7_default(panel.params.containerEl).eq(0) : app.$el;
    panel.containerEl = panel.$containerEl[0];
    if (!panel.containerEl) {
      panel.$containerEl = app.$el;
      panel.containerEl = app.$el[0];
    }
    let $el;
    if (panel.params.el) {
      $el = dom7_default(panel.params.el).eq(0);
    } else if (panel.params.content) {
      $el = dom7_default(panel.params.content).filter((node) => node.nodeType === 1).eq(0);
    }
    if ($el.length === 0)
      return panel;
    if ($el[0].f7Panel)
      return $el[0].f7Panel;
    $el[0].f7Panel = panel;
    let {
      side,
      effect,
      resizable
    } = panel.params;
    if (typeof side === "undefined")
      side = $el.hasClass("panel-left") ? "left" : "right";
    if (typeof effect === "undefined")
      effect = $el.hasClass("panel-cover") ? "cover" : $el.hasClass("panel-push") ? "push" : $el.hasClass("panel-floating") ? "floating" : "reveal";
    if (typeof resizable === "undefined")
      resizable = $el.hasClass("panel-resizable");
    let $backdropEl;
    if (panel.params.backdrop && panel.params.backdropEl) {
      $backdropEl = dom7_default(panel.params.backdropEl);
    } else if (panel.params.backdrop) {
      $backdropEl = panel.$containerEl.children(".panel-backdrop");
      if ($backdropEl.length === 0) {
        $backdropEl = dom7_default('<div class="panel-backdrop"></div>');
        panel.$containerEl.prepend($backdropEl);
      }
    }
    extend(panel, {
      app,
      side,
      effect,
      resizable,
      $el,
      el: $el[0],
      opened: false,
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0]
    });
    panel.useModules();
    panel.init();
    return panel;
  }
  getViewEl() {
    const panel = this;
    let viewEl;
    if (panel.$containerEl.children(".views").length > 0) {
      viewEl = panel.$containerEl.children(".views")[0];
    } else {
      viewEl = panel.$containerEl.children(".view")[0];
    }
    return viewEl;
  }
  setStateClasses(state) {
    const panel = this;
    const {
      side,
      el,
      effect
    } = panel;
    const viewEl = panel.getViewEl();
    const panelInView = viewEl && viewEl.contains(el);
    const $targetEl = !viewEl || panelInView ? panel.$containerEl : dom7_default("html");
    if (state === "open") {
      $targetEl.addClass(`with-panel with-panel-${panel.side}-${panel.effect}`);
    }
    if (state === "before-closing") {
      $targetEl.addClass("with-panel-closing");
    }
    if (state === "closing") {
      $targetEl.addClass("with-panel-closing");
      $targetEl.removeClass(`with-panel with-panel-${panel.side}-${panel.effect}`);
    }
    if (state === "after-closing") {
      $targetEl.removeClass("with-panel-closing");
    }
    if (state === "closed") {
      $targetEl.removeClass(`with-panel-${side}-${effect}`);
    }
  }
  enableVisibleBreakpoint() {
    const panel = this;
    panel.visibleBreakpointDisabled = false;
    panel.setVisibleBreakpoint();
    return panel;
  }
  disableVisibleBreakpoint() {
    const panel = this;
    panel.visibleBreakpointDisabled = true;
    panel.setVisibleBreakpoint();
    return panel;
  }
  toggleVisibleBreakpoint() {
    const panel = this;
    panel.visibleBreakpointDisabled = !panel.visibleBreakpointDisabled;
    panel.setVisibleBreakpoint();
    return panel;
  }
  setVisibleBreakpoint(emitEvents) {
    if (emitEvents === void 0) {
      emitEvents = true;
    }
    const panel = this;
    const app = panel.app;
    if (!panel.visibleBreakpointResizeHandler) {
      panel.visibleBreakpointResizeHandler = function visibleBreakpointResizeHandler() {
        panel.setVisibleBreakpoint();
      };
      app.on("resize", panel.visibleBreakpointResizeHandler);
    }
    const {
      side,
      $el,
      $containerEl,
      params,
      visibleBreakpointDisabled
    } = panel;
    const breakpoint = params.visibleBreakpoint;
    const $viewEl = dom7_default(panel.getViewEl());
    const wasVisible = $el.hasClass("panel-in-breakpoint");
    if ($containerEl && $containerEl.hasClass("page")) {
      $viewEl.add($containerEl.children(".page-content, .tabs, .fab"));
    }
    if (app.width >= breakpoint && typeof breakpoint !== "undefined" && breakpoint !== null && !visibleBreakpointDisabled) {
      if (!wasVisible) {
        panel.setStateClasses("closed");
        $el.addClass("panel-in-breakpoint").removeClass("panel-in panel-in-collapsed");
        panel.onOpen(false);
        panel.onOpened();
        $viewEl.css({
          [`margin-${side}`]: `${$el.width()}px`
        });
        app.allowPanelOpen = true;
        if (emitEvents) {
          panel.emit("local::breakpoint panelBreakpoint", panel);
          panel.$el.trigger("panel:breakpoint");
        }
      } else {
        $viewEl.css({
          [`margin-${side}`]: `${$el.width()}px`
        });
      }
    } else if (wasVisible) {
      $el.removeClass("panel-in-breakpoint panel-in");
      panel.onClose();
      panel.onClosed();
      $viewEl.css({
        [`margin-${side}`]: ""
      });
      if (emitEvents) {
        panel.emit("local::breakpoint panelBreakpoint", panel);
        panel.$el.trigger("panel:breakpoint");
      }
    }
  }
  enableCollapsedBreakpoint() {
    const panel = this;
    panel.collapsedBreakpointDisabled = false;
    panel.setCollapsedBreakpoint();
    return panel;
  }
  disableCollapsedBreakpoint() {
    const panel = this;
    panel.collapsedBreakpointDisabled = true;
    panel.setCollapsedBreakpoint();
    return panel;
  }
  toggleCollapsedBreakpoint() {
    const panel = this;
    panel.collapsedBreakpointDisabled = !panel.collapsedBreakpointDisabled;
    panel.setCollapsedBreakpoint();
    return panel;
  }
  setCollapsedBreakpoint(emitEvents) {
    if (emitEvents === void 0) {
      emitEvents = true;
    }
    const panel = this;
    const app = panel.app;
    if (!panel.collapsedBreakpointResizeHandler) {
      panel.collapsedBreakpointResizeHandler = function collapsedBreakpointResizeHandler() {
        panel.setCollapsedBreakpoint();
      };
      app.on("resize", panel.collapsedBreakpointResizeHandler);
    }
    const {
      $el,
      params,
      collapsedBreakpointDisabled
    } = panel;
    if ($el.hasClass("panel-in-breakpoint"))
      return;
    const breakpoint = params.collapsedBreakpoint;
    const wasVisible = $el.hasClass("panel-in-collapsed");
    if (app.width >= breakpoint && typeof breakpoint !== "undefined" && breakpoint !== null && !collapsedBreakpointDisabled) {
      if (!wasVisible) {
        panel.setStateClasses("closed");
        $el.addClass("panel-in-collapsed").removeClass("panel-in");
        panel.collapsed = true;
        app.allowPanelOpen = true;
        if (emitEvents) {
          panel.emit("local::collapsedBreakpoint panelCollapsedBreakpoint", panel);
          panel.$el.trigger("panel:collapsedbreakpoint");
        }
      }
    } else if (wasVisible) {
      $el.removeClass("panel-in-collapsed panel-in");
      panel.collapsed = false;
      if (emitEvents) {
        panel.emit("local::collapsedBreakpoint panelCollapsedBreakpoint", panel);
        panel.$el.trigger("panel:collapsedbreakpoint");
      }
    }
  }
  enableResizable() {
    const panel = this;
    if (panel.resizableInitialized) {
      panel.resizable = true;
      panel.$el.addClass("panel-resizable");
    } else {
      resizable_panel_default(panel);
    }
    return panel;
  }
  disableResizable() {
    const panel = this;
    panel.resizable = false;
    panel.$el.removeClass("panel-resizable");
    return panel;
  }
  enableSwipe() {
    const panel = this;
    if (panel.swipeInitialized) {
      panel.swipeable = true;
    } else {
      swipe_panel_default(panel);
    }
    return panel;
  }
  disableSwipe() {
    const panel = this;
    panel.swipeable = false;
    return panel;
  }
  onOpen(modifyHtmlClasses) {
    if (modifyHtmlClasses === void 0) {
      modifyHtmlClasses = true;
    }
    const panel = this;
    panel._openTransitionStarted = false;
    const app = panel.app;
    panel.opened = true;
    app.panel.allowOpen = false;
    panel.$el.trigger("panel:beforeopen");
    panel.emit("local::beforeOpen panelBeforeOpen", panel);
    if (modifyHtmlClasses) {
      panel.setStateClasses("open");
    }
    panel.$el.trigger("panel:open");
    panel.emit("local::open panelOpen", panel);
  }
  onOpened() {
    const panel = this;
    const app = panel.app;
    app.panel.allowOpen = true;
    panel.$el.trigger("panel:opened");
    panel.emit("local::opened panelOpened", panel);
  }
  onClose() {
    const panel = this;
    const app = panel.app;
    panel.opened = false;
    app.panel.allowOpen = false;
    panel.$el.trigger("panel:beforeclose");
    panel.emit("local::beforeClose panelBeforeClose", panel);
    panel.setStateClasses("closing");
    panel.$el.trigger("panel:close");
    panel.emit("local::close panelClose", panel);
  }
  onClosed() {
    const panel = this;
    const app = panel.app;
    app.panel.allowOpen = true;
    panel.setStateClasses("after-closing");
    panel.$el.removeClass("panel-out");
    if (panel.$backdropEl) {
      const otherPanel = app.panel.get(".panel-in");
      const shouldHideBackdrop = !otherPanel || otherPanel && !otherPanel.$backdropEl;
      if (shouldHideBackdrop) {
        panel.$backdropEl.removeClass("panel-backdrop-in");
      }
    }
    panel.$el.trigger("panel:closed");
    panel.emit("local::closed panelClosed", panel);
  }
  toggle(animate) {
    if (animate === void 0) {
      animate = true;
    }
    const panel = this;
    const breakpoint = panel.params.visibleBreakpoint;
    const app = panel.app;
    if (app.width >= breakpoint && typeof breakpoint !== "undefined" && breakpoint !== null) {
      return panel.toggleVisibleBreakpoint();
    }
    if (panel.opened)
      panel.close(animate);
    else
      panel.open(animate);
    return panel;
  }
  insertToRoot() {
    const panel = this;
    const document = getDocument();
    const {
      $el,
      $backdropEl,
      $containerEl
    } = panel;
    const $panelParentEl = $el.parent();
    const wasInDom = $el.parents(document).length > 0;
    if (!$panelParentEl.is($containerEl) || $el.prevAll(".views, .view").length) {
      const $insertBeforeEl = $containerEl.children(".panel, .views, .view").eq(0);
      const $insertAfterEl = $containerEl.children(".panel-backdrop").eq(0);
      if ($insertBeforeEl.length) {
        $el.insertBefore($insertBeforeEl);
      } else if ($insertAfterEl) {
        $el.insertBefore($insertAfterEl);
      } else {
        $containerEl.prepend($el);
      }
      if ($backdropEl && $backdropEl.length && (!$backdropEl.parent().is($containerEl) && $backdropEl.nextAll(".panel").length === 0 || $backdropEl.parent().is($containerEl) && $backdropEl.nextAll(".panel").length === 0)) {
        $backdropEl.insertBefore($el);
      }
      panel.once("panelClosed", () => {
        if (wasInDom) {
          $panelParentEl.append($el);
        } else {
          $el.remove();
        }
      });
    }
  }
  open(animate) {
    if (animate === void 0) {
      animate = true;
    }
    const panel = this;
    const app = panel.app;
    if (!app.panel.allowOpen)
      return false;
    const {
      effect,
      $el,
      $backdropEl,
      opened,
      $containerEl
    } = panel;
    if (!$el || $el.hasClass("panel-in")) {
      return panel;
    }
    panel.insertToRoot();
    if (opened || $el.hasClass("panel-in-breakpoint") || $el.hasClass("panel-in"))
      return false;
    const otherOpenedPanel = app.panel.get(".panel-in");
    if (otherOpenedPanel && otherOpenedPanel !== panel) {
      otherOpenedPanel.close(animate);
    }
    $el[animate ? "removeClass" : "addClass"]("not-animated");
    $el.addClass("panel-in");
    if ($backdropEl) {
      $backdropEl.addClass("panel-backdrop-in");
      $backdropEl[animate ? "removeClass" : "addClass"]("not-animated");
    }
    if (["cover", "push", "floating"].includes(panel.effect)) {
      panel._clientLeft = $el[0].clientLeft;
    }
    const $viewEl = dom7_default(panel.getViewEl());
    if ($containerEl && $containerEl.hasClass("page")) {
      $viewEl.add($containerEl.children(".page-content, .tabs"));
    }
    const transitionEndTarget = effect === "reveal" ? $viewEl : $el;
    function panelTransitionStart() {
      transitionEndTarget.transitionStart(() => {
        panel._openTransitionStarted = true;
      });
    }
    function panelTransitionEnd() {
      transitionEndTarget.transitionEnd((e) => {
        if (dom7_default(e.target).is(transitionEndTarget)) {
          if ($el.hasClass("panel-out")) {
            panel.onClosed();
          } else {
            panel.onOpened();
          }
        } else
          panelTransitionEnd();
      });
    }
    if (animate) {
      if ($backdropEl) {
        $backdropEl.removeClass("not-animated");
      }
      panelTransitionStart();
      panelTransitionEnd();
      $el.removeClass("panel-out not-animated").addClass("panel-in");
      panel.onOpen();
    } else {
      if ($backdropEl) {
        $backdropEl.addClass("not-animated");
      }
      $el.removeClass("panel-out").addClass("panel-in not-animated");
      panel.onOpen();
      panel.onOpened();
      panel._openTransitionStarted = true;
    }
    return true;
  }
  close(animate) {
    if (animate === void 0) {
      animate = true;
    }
    const panel = this;
    const {
      effect,
      $el,
      $backdropEl,
      opened,
      $containerEl
    } = panel;
    if (!opened || $el.hasClass("panel-in-breakpoint") || !$el.hasClass("panel-in"))
      return panel;
    $el[animate ? "removeClass" : "addClass"]("not-animated");
    if ($backdropEl) {
      $backdropEl[animate ? "removeClass" : "addClass"]("not-animated");
    }
    const $viewEl = dom7_default(panel.getViewEl());
    if ($containerEl && $containerEl.hasClass("page")) {
      $viewEl.add($containerEl.children(".page-content, .tabs"));
    }
    const transitionEndTarget = effect === "reveal" ? $viewEl : $el;
    if (!panel._openTransitionStarted) {
      animate = false;
    }
    function transitionEnd() {
      if ($el.hasClass("panel-out")) {
        panel.onClosed();
      } else if ($el.hasClass("panel-in")) {
        panel.onOpened();
      }
      panel.setStateClasses("after-closing");
    }
    if (animate) {
      transitionEndTarget.transitionEnd(() => {
        transitionEnd();
      });
      $el.removeClass("panel-in").addClass("panel-out");
      panel.onClose();
    } else {
      $el.addClass("not-animated").removeClass("panel-in").addClass("panel-out");
      panel.onClose();
      panel.onClosed();
    }
    return panel;
  }
  init() {
    const panel = this;
    if (typeof panel.params.visibleBreakpoint !== "undefined") {
      panel.setVisibleBreakpoint();
    }
    if (typeof panel.params.collapsedBreakpoint !== "undefined") {
      panel.setCollapsedBreakpoint();
    }
    if (panel.params.swipe) {
      panel.enableSwipe();
    }
    if (panel.resizable) {
      panel.enableResizable();
    }
  }
  destroy() {
    let panel = this;
    const app = panel.app;
    const {
      $containerEl
    } = panel;
    if (!panel.$el) {
      return;
    }
    panel.emit("local::beforeDestroy panelBeforeDestroy", panel);
    panel.$el.trigger("panel:beforedestroy");
    if (panel.visibleBreakpointResizeHandler) {
      app.off("resize", panel.visibleBreakpointResizeHandler);
    }
    if (panel.collapsedBreakpointResizeHandler) {
      app.off("resize", panel.collapsedBreakpointResizeHandler);
    }
    if (panel.$el.hasClass("panel-in-breakpoint") || panel.$el.hasClass("panel-in-collapsed")) {
      const $viewEl = dom7_default(panel.getViewEl());
      if ($containerEl && $containerEl.hasClass("page")) {
        $viewEl.add($containerEl.children(".page-content, .tabs"));
      }
      panel.$el.removeClass("panel-in-breakpoint panel-in-collapsed panel-in");
      $viewEl.css({
        [`margin-${panel.side}`]: ""
      });
      panel.emit("local::breakpoint panelBreakpoint", panel);
      panel.$el.trigger("panel:breakpoint");
    }
    panel.$el.trigger("panel:destroy");
    panel.emit("local::destroy panelDestroy", panel);
    if (panel.el) {
      panel.el.f7Panel = null;
      delete panel.el.f7Panel;
    }
    deleteProps(panel);
    panel = null;
  }
};
var panel_class_default = Panel;

// node_modules/framework7/components/panel/panel.js
var panel_default = {
  name: "panel",
  params: {
    panel: {
      opened: void 0,
      // default based on panel-in class
      side: void 0,
      // default based on panel class
      effect: void 0,
      // default based on panel class
      resizable: void 0,
      // default based on panel-resizable class
      backdrop: true,
      backdropEl: void 0,
      visibleBreakpoint: void 0,
      collapsedBreakpoint: void 0,
      swipe: false,
      // or true
      swipeNoFollow: false,
      // or true
      swipeOnlyClose: false,
      swipeActiveArea: 0,
      swipeThreshold: 0,
      closeByBackdropClick: true,
      containerEl: void 0
    }
  },
  static: {
    Panel: panel_class_default
  },
  create() {
    const app = this;
    extend(app, {
      panel: {
        allowOpen: true,
        create(params) {
          return new panel_class_default(app, params);
        },
        get(el) {
          if (el === void 0) {
            el = ".panel";
          }
          if (el instanceof panel_class_default)
            return el;
          if (el === "left" || el === "right")
            el = `.panel-${el}`;
          const $el = dom7_default(el);
          if ($el.length === 0 || $el.length > 1)
            return void 0;
          return $el[0].f7Panel;
        },
        destroy(el) {
          if (el === void 0) {
            el = ".panel";
          }
          const panel = app.panel.get(el);
          if (panel && panel.destroy)
            return panel.destroy();
          return void 0;
        },
        open(el, animate) {
          if (el === void 0) {
            el = ".panel";
          }
          if (el === "left" || el === "right")
            el = `.panel-${el}`;
          let panel = app.panel.get(el);
          if (panel && panel.open)
            return panel.open(animate);
          if (!panel) {
            panel = app.panel.create({
              el
            });
            return panel.open(animate);
          }
          return void 0;
        },
        close(el, animate) {
          if (el === void 0) {
            el = ".panel-in";
          }
          if (el === "left" || el === "right")
            el = `.panel-${el}`;
          let panel = app.panel.get(el);
          if (panel && panel.open)
            return panel.close(animate);
          if (!panel) {
            panel = app.panel.create({
              el
            });
            return panel.close(animate);
          }
          return void 0;
        },
        toggle(el, animate) {
          if (el === void 0) {
            el = ".panel";
          }
          if (el === "left" || el === "right")
            el = `.panel-${el}`;
          let panel = app.panel.get(el);
          if (panel && panel.toggle)
            return panel.toggle(animate);
          if (!panel) {
            panel = app.panel.create({
              el
            });
            return panel.toggle(animate);
          }
          return void 0;
        }
      }
    });
  },
  on: {
    init() {
      const app = this;
      dom7_default(".panel-init").each((panelEl) => {
        const params = Object.assign({
          el: panelEl
        }, dom7_default(panelEl).dataset() || {});
        app.panel.create(params);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".panel-init").each((panelEl) => {
        const params = Object.assign({
          el: panelEl
        }, dom7_default(panelEl).dataset() || {});
        app.panel.create(params);
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".panel-init").each((panelEl) => {
        const panel = app.panel.get(panelEl);
        if (panel && panel.destroy)
          panel.destroy();
      });
    }
  },
  vnode: {
    "panel-init": {
      insert(vnode) {
        const app = this;
        const panelEl = vnode.elm;
        const params = Object.assign({
          el: panelEl
        }, dom7_default(panelEl).dataset() || {});
        app.panel.create(params);
      },
      destroy(vnode) {
        const app = this;
        const panelEl = vnode.elm;
        const panel = app.panel.get(panelEl);
        if (panel && panel.destroy)
          panel.destroy();
      }
    }
  },
  clicks: {
    ".panel-open": function open(clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.panel.open(data.panel, data.animate);
    },
    ".panel-close": function close(clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.panel.close(data.panel, data.animate);
    },
    ".panel-toggle": function close2(clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.panel.toggle(data.panel, data.animate);
    },
    ".panel-backdrop": function close3() {
      const app = this;
      const $panelEl = dom7_default(".panel-in:not(.panel-out)");
      if (!$panelEl.length)
        return;
      const instance = $panelEl[0] && $panelEl[0].f7Panel;
      $panelEl.trigger("panel:backdrop-click");
      if (instance) {
        instance.emit("backdropClick", instance);
      }
      app.emit("panelBackdropClick", instance || $panelEl[0]);
      if (instance && instance.params.closeByBackdropClick === false)
        return;
      if (app.params.panel.closeByBackdropClick)
        app.panel.close();
    }
  }
};
export {
  panel_default as default
};
//# sourceMappingURL=framework7_components_panel.js.map
